// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

#include "kudu/util/mini_prometheus.h"

#include <csignal>
#include <fstream>
#include <vector>

#include <glog/logging.h>

#include "kudu/gutil/strings/join.h"
#include "kudu/gutil/strings/substitute.h"
#include "kudu/util/env.h"
#include "kudu/util/net/sockaddr.h"
#include "kudu/util/net/socket.h"
#include "kudu/util/path_util.h"
#include "kudu/util/subprocess.h"
#include "kudu/util/test_util.h"

using std::string;
using std::vector;
using strings::Substitute;

namespace kudu {

MiniPrometheus::MiniPrometheus() : web_port_(0) {
}

MiniPrometheus::~MiniPrometheus() {
  WARN_NOT_OK(Stop(), "Failed to stop Prometheus");
}

Status MiniPrometheus::Start() {
  // Start with empty target list (no scraping)
  return Start(vector<string>());
}

Status MiniPrometheus::Start(const vector<string>& target_urls) {
  // Find an available port for the web interface
  RETURN_NOT_OK(FindAvailablePort());
  
  // Find the Prometheus binary using the standard Kudu pattern
  string prometheus_path;
  string exe;
  RETURN_NOT_OK(Env::Default()->GetExecutablePath(&exe));
  const string bin_dir = DirName(exe);
  
  // Try thirdparty location first (for tests), then system PATH
  static const vector<string> kCommonLocations = {
    JoinPathSegments(bin_dir, "../../../thirdparty/installed/common/bin"), // Thirdparty build
  };
  
  Status s = FindExecutable("prometheus", kCommonLocations, &prometheus_path);
  if (!s.ok()) {
    // Fallback to system prometheus
    prometheus_path = "prometheus";
  }

  // Build Prometheus command line
  vector<string> argv = {
    prometheus_path,
    "--log.level=info",
    Substitute("--web.listen-address=127.0.0.1:$0", web_port_)
  };

  // If we have target URLs, create a config file
  if (!target_urls.empty()) {
    // Create a temporary config file
    config_file_path_ = JoinPathSegments(GetTestDataDirectory(), "prometheus_config.yml");
    
    string config_content = GenerateScrapeConfig(target_urls);
    std::ofstream config_file(config_file_path_);
    if (!config_file.is_open()) {
      return Status::IOError("Failed to create Prometheus config file", config_file_path_);
    }
    config_file << config_content;
    config_file.close();
    
    // Add config file to command line
    argv.push_back(Substitute("--config.file=$0", config_file_path_));
    
    LOG(INFO) << "Created Prometheus config file: " << config_file_path_;
  }

  LOG(INFO) << "Starting Prometheus with command: " << JoinStrings(argv, " ");

  process_.reset(new Subprocess(argv));
  process_->ShareParentStdout(false);
  RETURN_NOT_OK_PREPEND(process_->Start(), "Failed to start Prometheus process");

  LOG(INFO) << "Started Prometheus";
  return Status::OK();
}

Status MiniPrometheus::Stop() {
  if (process_ && process_->IsStarted()) {
    LOG(INFO) << "Stopping Prometheus";
    RETURN_NOT_OK_PREPEND(process_->KillAndWait(SIGTERM), "Failed to stop Prometheus");
    process_.reset();
  }
  
  // Clean up config file if it was created
  if (!config_file_path_.empty()) {
    Status s = Env::Default()->DeleteFile(config_file_path_);
    if (!s.ok()) {
      LOG(WARNING) << "Failed to delete Prometheus config file: " << config_file_path_ 
                   << " - " << s.ToString();
    }
    config_file_path_.clear();
  }
  
  return Status::OK();
}

bool MiniPrometheus::IsRunning() const {
  return process_ && process_->IsStarted();
}

string MiniPrometheus::GenerateScrapeConfig(const vector<string>& target_urls) {
  string config = R"(# Prometheus configuration generated by MiniPrometheus
global:
  scrape_interval: 5s
  evaluation_interval: 5s

scrape_configs:
  - job_name: 'kudu-test'
    metrics_path: '/metrics'
    static_configs:
      - targets: [)";
  
  // Add the target URLs
  vector<string> quoted_targets;
  for (const string& url : target_urls) {
    quoted_targets.push_back(Substitute("'$0'", url));
  }
  config += JoinStrings(quoted_targets, ", ");
  
  config += R"(]
        labels:
          job: 'kudu-test'
)";
  
  return config;
}

Status MiniPrometheus::FindAvailablePort() {
  Sockaddr addr;
  RETURN_NOT_OK(addr.ParseString("127.0.0.1:0", 0));
  
  Socket socket;
  RETURN_NOT_OK(socket.Init(addr.family(), 0));
  RETURN_NOT_OK(socket.BindAndListen(addr, 1));
  
  Sockaddr bound_addr;
  RETURN_NOT_OK(socket.GetSocketAddress(&bound_addr));
  web_port_ = bound_addr.port();
  
  // Close the socket so Prometheus can bind to it
  RETURN_NOT_OK(socket.Close());
  
  return Status::OK();
}

string MiniPrometheus::web_url() const {
  return Substitute("http://127.0.0.1:$0", web_port_);
}

} // namespace kudu 